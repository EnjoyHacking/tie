/*
 *  src/common/common.h - Component of the TIE v1.0.0-beta3 platform 
 *
 *  Copyright (C) 2007-2011 Alberto Dainotti, Walter de Donato,
 *                            Antonio Pescape', Alessio Botta.
 *  Email: alberto@unina.it, walter.dedonato@unina.it,
 *         pescape@unina.it, a.botta@unina.it 
 *
 *  DIS - Dipartimento di Informatica e Sistemistica (Computer Science Department)
 *  University of Naples Federico II
 *  All rights reserved.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#ifndef H_COMMON
#define H_COMMON

/*
 * Dependences
 */
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <stdio.h>
#include <stdlib.h>
#if FreeBSD
#include <sys/time.h>
#endif


/*
 * Constants
 */
#define PRINT_STATUS			100000	/* Print status information each PRINT_STATUS pkts processed */
#define MAX_PAYLOAD			1550	/* 1550 */
#define MAX_SRCF			50	/* Max number of trace files in input */
#define MAX_BUFFER			255	/* Max buffer size for snprintf() */

#define TIE_SYM_LINK 			"/usr/local/bin/tie" /* Sim-link location */

/* Session types */
#define SESS_TYPE_HOST			1
#define SESS_TYPE_FLOW			2
#define SESS_TYPE_BIFLOW		3

/* Operating modes */
#define MODE_OFFLINE			1
#define MODE_CYCLIC			2
#define MODE_REALTIME			3

/* Flags for periodical dump of data and garbage collection */
#define DUMP_ALL			0x1
#define DUMP_EXPIRED			0x2
#define DUMP_INTERVAL			0x4
#define FREE_EXPIRED			0x8
#define FREE_ALL			0x10


/*
 * Macros
 */
#define MIN(a,b)			(((a) < (b)) ? (a) : (b))
#define MAX(a,b)			(((a) < (b)) ? (b) : (a))

#define ADDR2INT(a)			(u_long)((a[0] << 24) + (a[1] << 16) + (a[2] << 8) + a[3])

#define IS_DIGIT(x)			( (x >= '0') && (x <= '9') )

/* Bit operations: r = register, b = bit mask, v = value (0|1) */
#define SET_BIT(r,b,v)			((v == 1) ? (r |= b) : (r &= ~b))
#define TEST_BIT(r,b,v)			((v == 1) ? ((r & b) == b) : ((r & b) == 0))

/* convert a timeval to an int */
#define TV_TO_QUAD(a)			(((u_quad_t)(a.tv_sec) * 1000000) + (u_quad_t)a.tv_usec)

/* subtract 2 timevals and convert to int */
#define TV_SUB_TO_QUAD(a,b)		(u_quad_t)(TV_TO_QUAD(a) - TV_TO_QUAD(b))

/* Debug output macros */
#ifdef DEBUG
#define PRINTD(...);			fprintf(stderr,__VA_ARGS__);
#else
#define PRINTD(...);
#endif
#define PRINTDD(...);			/* to make inactive a debugging command just add a second "D" :-) */
#define PRINTDDL(...);


/*
 * Types
 */
typedef enum {
	false, true
} bool;

typedef struct {
	u_int16_t l4proto;			/* layer 4 protocol */
	struct in_addr src_ip;			/* source IP */
	struct in_addr dst_ip;			/* destination IP */
	u_int16_t src_port;			/* source port */
	u_int16_t dst_port;			/* destination port */
} five_tuple;

typedef struct program_variables {
	int readmode;				/* read pkts from a tcpdump file rather than from network interface */
	char *sourcefile[MAX_SRCF];		/* tcpdump format source files name */
	int writemode;				/* dump pkts in to a tcpdump file */
	char *destfile;				/* tcpdump format destination file name */
	int filter_disable;			/* disable pkt filtering (and subsequently pkt processing) */
	bool tcp_heuristics;			/* enable TCP heuristics to detect session closure */
	char *device;				/* network interface to use */
	int snaplen;				/* capture only # bytes from each pkt */
	u_long start_pkts;			/* start after # pkts */
	u_long stop_pkts;			/* stop after # pkts */
	long int session_timeout;		/* expressed in seconds */
	char *directory;			/* directory where to store exported data */
	char *hosttable;			/* file form which to read host table, generated by Wmode 1 */
	char *filter_file;			/* file from which to read pcap filter commands */
	int time_range;				/* capture only pkts with timestamp in specified time range */
	int day_of_week;			/* capture only pkts with timestamp in specified day of week */
	int tr_hmin;				/* time range min hour */
	int tr_mmin;				/* time range min minute */
	int tr_hmax;				/* time range max hour */
	int tr_mmax;				/* time range max minute */
	int dump_headers;			/* when writing to a file, truncate pkts to TCP header end + dump_headers */
	int zero;				/* zero out ip addresses in dump */
	int tz;					/* timezone + daylight saving imposed by user */
	int stype;				/* session type: 1) Host  2) Flow 3) BiFlow */
	int wmode;				/* working mode: 1) Off-line 2) Cyclic 3) Real-time */
	u_int32_t clean_interval;		/* Interval (in # of pkts) for periodical dumping of data and garbage collection */
	bool labels;				/* Resolve classification ids with labels */
	u_int16_t cycle;			/* Cycle time in cyclic mode (in seconds) */

	char *pre_class_file;			/* classification input file name */
	u_int16_t gt_app_count;			/* number of applications detected from input file */
	char *class_out_file;			/* classification output file name */
	struct in_addr rh_addr;			/* remote host IP address */
	u_int rh_port;				/* remote host listening port */
	bool rh_keep_alive;			/* defines the persistence of the TCP connection to the remote host */
	int ro_pipe;				/* dispatcher pipe identifier (write_only) */

	bool class;				/* activate traffic classification routines */
	u_int16_t training;			/* activate classifiers training routines passing a threshold value */
	char *sign_suffix;			/* suffix to append to generated signature files */
	u_int8_t pl_inspect;			/* Payload inspection: specifies the number of bytes to record from first packet(s) */
	u_int8_t psize;				/* Payload-size collection: specifies how many payload-sizes per session will be recorded */
	u_int8_t pktsize;			/* Packet-size collection: specifies how many packet-sizes per session will be recorded */
	u_int8_t ipts;				/* IPTs collection: specifies how many IPTs per session will be recorded */
	u_int16_t stream_len;			/* Payload stream collection: specifies how many bytes per session will be recorded */
} program_variables;

typedef struct statistics {
	time_t cpu_start;			/* date & time when program was started */
	time_t cpu_end;				/* date & time when program finished processing data */
	int tzoff;				/* Time zone offset */
	struct timeval tv_start;		/* timestamp of the first packet read */
	struct timeval tv_end;			/* timestamp of the last packet read */
	struct timeval tv_last_cycle;		/* timestamp of the last packet associated to a cyclic dump */
	int frame_offset;
	u_quad_t pkts;
	u_quad_t discarded;
	u_quad_t frags;
	u_quad_t truncated;
	u_quad_t err_payload;
	u_quad_t ip_options;
	u_quad_t skipped_pkts;
	u_quad_t bad_pkts;
	u_quad_t dup_pkts;
	int interrupted;			/* program was interrupted by user (CTRL-C) */
} statistics;


/*
 * Public variables (maintained by tie.c)
 */
extern program_variables pv;
extern statistics stats;
extern int g_argc;			/* Global command-line arguments counter */
extern char **g_argv;			/* Global command-line arguments vector */
extern uid_t uid;			/* Sudoer user ID */
extern gid_t gid;			/* Sudoer group ID */
extern char tie_path[MAX_BUFFER];	/* TIE base directory */

#endif
